# Report for Lab 2

Operating System Engineering(Honor Track, 2019 Spring)

Jing Mai, 1700012751

------

# Getting started
First of all, as I recreate a private repository on my own github account, I have to fetch the branch `lab2` from `https://pdos.csail.mit.edu/6.828/2018/jos.git`.

```bash
git remote add mit https://pdos.csail.mit.edu/6.828/2018/jos.git
git remote -v
git fetch mit
git checkout -b lab2
git merge mit/lab2
git push --set-upstream origin lab2
````

# Part 1: Physical Page Management

As we had known in lab1, we set up a trivial page directory that translates virtual addresses `[KERNBASE, KERNBASE+4MB) `to physical addresses `[0, 4MB)`.  This 4MB region will be sufficient until we set up our real page table in `mem_init` in lab 2.

> **Exercise 1.** In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
>
> ```
> boot_alloc()
> mem_init() (only up to the call to check_page_free_list(1))
> page_init()
> page_alloc()
> page_free()
> ```
>
> `check_page_free_list()` and `check_page_alloc()` test your physical page allocator. You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.

in `kern/pmap.c:boot_alloc`:

```c++
// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	
	if (n == 0)
		return nextfree;
	
	char * res = nextfree;
	char * upaddr= ROUNDUP(nextfree + n, PGSIZE); // "nextfree" after allocating memory
	char * upbound = (char*)(KERNBASE + npages * PGSIZE); // upper bound of Remapped Physical Memory in virtual space

	if( upaddr > upbound)	// out of memory
		panic("Out of memory. nextfree = %p, upper bound of chunk = %p, \n" \
			"\tupper bound of remapped physical memory in virtual space: %p, \n" \
			"\tn = %u, PGSIZE = %u\n",
			nextfree, upaddr, upbound, n, PGSIZE);
	
	nextfree = upaddr;
	return res;

}
```

We use the variable `npages`  to check whether we are going to be out of memory.

In `kern/pmap.c:mem_init`:

```c++
//////////////////////////////////////////////////////////////////////
    // create initial page directory.
    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
    memset(kern_pgdir, 0, PGSIZE);

    //////////////////////////////////////////////////////////////////////
    // Recursively insert PD in itself as a page table, to form
    // a virtual page table at virtual address UVPT.
    // (For now, you don't have understand the greater purpose of the
    // following line.)

    // Permissions: kernel R, user R
    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    //////////////////////////////////////////////////////////////////////
    // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
    // The kernel uses this array to keep track of physical pages: for
    // each physical page, there is a corresponding struct PageInfo in this
    // array.  'npages' is the number of physical pages in memory.  Use memset
    // to initialize all fields of each struct PageInfo to 0.
    // Your code goes here:

    pages = (struct PageInfo *)boot_alloc(sizeof(struct PageInfo) * npages);
    memset(pages, 0, sizeof(struct PageInfo) * npages);
```

As for the usage the instruction `kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P`, it offers a way for users to read page directory/tables. Note that the variable `kern_pgdir` is actually high then `KERNBASE`, which is unvisitable to users.

in `kern/pamp.c:page_init`:

```c++
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	physaddr_t curupper = (physaddr_t)PADDR(boot_alloc(0));		// next free page in physical memory

	page_free_list = NULL;

	for (i = 0; i < npages; i++) {
		physaddr_t ptr = i * PGSIZE;								// the beginning physical address of page i

		pages[i].pp_ref = 0;
		
		if((0 < i && i < npages_basemem)						// the rest of base memory is free.
			|| (ptr >= EXTPHYSMEM && ptr >= curupper)){			// free extended memory
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
}
```

in `kern/pmap.c:page_alloc`:

```c++
struct PageInfo *
page_alloc(int alloc_flags)
{	

	if(!page_free_list)
		return NULL;

	struct PageInfo *page_ptr = page_free_list;
	page_free_list = page_ptr -> pp_link;
	page_ptr -> pp_link = NULL;

	if( alloc_flags & ALLOC_ZERO)
		memset(page2kva(page_ptr), 0, PGSIZE);
	
	return page_ptr;
}
```

in `kern/pmap.c:page_free`:

```c++
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp ->pp_ref != 0)
		panic("pp->pp_ref is nonzero.");
	
	if(pp->pp_link != NULL)
		panic("pp->pp_link is not NULL.");

	pp->pp_link = page_free_list;
	page_free_list = pp;

}
```

# Part 2: Virtual Memory

> **Question**
>
> 1. Assuming that the following JOS kernel code is correct, what type should variable `x` have , `uintptr_t` or `physaddr_t`?
>    ```
>    	mystery_t x;
>    	char* value = return_a_pointer();
>    	*value = 10;
>    	x = (mystery_t) value;
>    ```

The type of variable `x` should be `uintptr_t`.

> **Exercise 4.** In the file `kern/pmap.c`, you must implement code for the following functions.
>
> ```
>         pgdir_walk()
>         boot_map_region()
>         page_lookup()
>         page_remove()
>         page_insert()
> 	
> ```
>
> `check_page()`, called from `mem_init()`, tests your page table management routines. You should make sure it reports success before proceeding.

Here JOS offers two-stage page translation mechanism. And the usage of three page directory/table entry flags are listed following:

![1569658417549](.\pics\1569658417549.png)

- `PTE_P` : When `PTE_P=0` in either level of page tables, the entry is not valid for address translation, and the rest of the entry is available for software use; none of the other bits in the entry is tested by the hardware. 
- `PTE_W` and `PTE_U`: These bits are not used for address translation, but are used for page-level protection, which the processor performs at the same time as address translation.

in `kern/pmap.c:pgdir_walk`:

```c++
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{

	pde_t pde = pgdir[PDX(va)];	// size of a page directory entry is sizeof(*pgdir) = 2^2 Byte
												
	if(!(pde & PTE_P)){			// the relevant page table page does not exist.
		if(!create)
			return NULL;

		// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
		// If the allocation fails, pgdir_walk returns NULL.
		// The new page is cleared.
		struct PageInfo *pgtbl_page;
		if(!(pgtbl_page = page_alloc(ALLOC_ZERO)))
			return NULL;
		
		// create a page table
		pgtbl_page->pp_ref++;

		// it's safe to leave permissions in the page directory more permissive 
		// than strictly necessary.
		pgdir[PDX(va)] = page2pa(pgtbl_page) | PTE_P | PTE_U | PTE_W;
		
		// reassign after creating a new page table
		pde = pgdir[PDX(va)];	
	}
	
	pte_t *pgtbl = (pte_t *)KADDR(PTE_ADDR(pde));
	return pgtbl + PTX(va);
}
```

in `kern/pmap.c:boot_map_region`:

```c++
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm){
	assert(size % PGSIZE == 0);
	assert(va % PGSIZE == 0);
	assert(pa % PGSIZE == 0);

	for(size_t i = 0; i < size; i+= PGSIZE){
		pte_t *pte = pgdir_walk(pgdir, (void*)va + i, 1);
		if(!pte)
			panic("boot_map_region panic, out of memory");

		*pte = (pa + i) | perm | PTE_P;
	}
}
```

in `kern/pmap.c:boot_map_region`:

```c++
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm){
	assert(size % PGSIZE == 0);
	assert(va % PGSIZE == 0);
	assert(pa % PGSIZE == 0);

	for(size_t i = 0; i < size; i+= PGSIZE){
		pte_t *pte = pgdir_walk(pgdir, (void*)va + i, 1);
		if(!pte)
			panic("boot_map_region panic, out of memory");

		*pte = (pa + i) | perm | PTE_P;
	}
}
```

in `kern/pmap.c:page_lookup`:

```c++
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	pte_t *pte = pgdir_walk(pgdir,va,0);
	
	// Return NULL if there is no page mapped at va.
	if(!pte || !(*pte & PTE_P))
		return NULL;

	// If pte_store is not zero, then we store in it the address
	// of the pte for this page.
	if(pte_store)
		*pte_store = pte;

	return pa2page(PTE_ADDR(*pte));
	
}
```

in `kern/pmap.c:page_remove:`

```c++
void
page_remove(pde_t *pgdir, void *va)
{
	pte_t * pte;
	struct PageInfo *pp = page_lookup(pgdir, va, &pte);

	// If there is no physical page at that address, silently does nothing.
	if(!pp)
		return;
	
	// The ref count on the physical page should decrement.
	// The physical page should be freed if the refcount reaches 0.
	page_decref(pp);
	
	// The pg table entry corresponding to 'va' should be set to 0.
	* pte = 0;

	// The TLB must be invalidated if you remove an entry from the page table.
	tlb_invalidate(pgdir, va);

}
```

in `kern/pmap.c:page_insert`:

```c++
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	pte_t *pte;
	
	// If necessary, on demand, a page table should be allocated and inserted into 'pgdir'.
	// return -E_NO_MEM, if page table couldn't be allocated
	if (!(pte = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
	
	//increase ref count beforehand to avoid the corner case 
	// that pp is freed before it is inserted.
	pp->pp_ref++;

	// If there is already a page mapped at 'va', it should be page_remove()d.
	if (*pte & PTE_P)
		page_remove(pgdir, va);
	
	*pte = page2pa(pp) | perm | PTE_P;
	
	return 0;
}
```

### UVPT & UVPD

In JOS, the page directory is the `0x3BD` in virtual memory.

- `UVPT = 0x3BD<<22=0xEF400000`

- `UVPD=(0x3BD<<22 | 0x3BD<<12)=UVPT | (UVPT>>10) = ‭0xEF40EF40000‬`
- What is the physical address of page directory?
  - The virtual address that contains page directory's physical address is `0xef7bdef4 = [PDX(UVPT), PDX(UVPT), PDX(UVPT), 00] = UVPT + (UVPT >> 10) + (UVPT >> 20)`
- What is the physical address of page directory of `va`?
  - The virtual address the contains `va`'s physical address in page directory is `[PDX(UVPT), PDX(UVPT), PDX(va), 00]`
  - i.e. `[PGNUM(UVPD), PDX(va), 00]`
- What is the physical address of page table of `va`?
  - The virtual address the contains `va`'s physical address in page table is `[PDX(UVPT), PDX(va), PTX(va),00]`
- The PTE for page number N is stored in `uvpt[N]`
- The PDE for the Nth entry in page directory is `uvpd[N]`
# Part 3: Kernel Address Space

> **Exercise 5.** Fill in the missing code in `mem_init()` after the call to `check_page()`.
>
> Your code should now pass the `check_kern_pgdir()` and `check_page_installed_pgdir()` checks.

in `kern/pmap.c:mem_init`:

```c++
// the new image at UPAGES -- kernel R, user R
	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);	

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel	
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	// [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	// Permissions: kernel RW, user NONE
	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KERNBASE, ((uint64_t)1<<32) - KERNBASE, 0, PTE_W);
```

> **Question **
>
> 2. What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:

We can analysis the result of `info pg`  and the virtual memory layout in `inc/memlayout.h`. Notice that the offset of page directory index in a linear address in `22`. 

```bash
(qemu) info pg
VPN range     Entry         Flags        Physical page
[ef000-ef3ff]  PDE[3bc]     -------UWP
  [ef000-ef3ff]  PTE[000-3ff] -------U-P 0011c-0051b
[ef400-ef7ff]  PDE[3bd]     -------U-P
  [ef7bc-ef7bc]  PTE[3bc]     -------UWP 003fd
  [ef7bd-ef7bd]  PTE[3bd]     -------U-P 0011b
  [ef7bf-ef7bf]  PTE[3bf]     -------UWP 003fe
  [ef7c0-ef7df]  PTE[3c0-3df] ----A--UWP 003ff 003fc 003fb 003fa 003f9 003f8 ..
  [ef7e0-ef7ff]  PTE[3e0-3ff] -------UWP 003dd 003dc 003db 003da 003d9 003d8 ..
[efc00-effff]  PDE[3bf]     -------UWP
  [efff8-effff]  PTE[3f8-3ff] --------WP 0010f-00116
[f0000-f03ff]  PDE[3c0]     ----A--UWP
  [f0000-f0000]  PTE[000]     --------WP 00000
  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f
  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7
  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8
  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff
  [f0100-f0105]  PTE[100-105] ----A---WP 00100-00105
  [f0106-f0115]  PTE[106-115] --------WP 00106-00115
  [f0116-f0116]  PTE[116]     ---DA---WP 00116
  [f0117-f0117]  PTE[117]     --------WP 00117
  [f0118-f0118]  PTE[118]     ---DA---WP 00118
  [f0119-f0119]  PTE[119]     --------WP 00119
  [f011a-f011b]  PTE[11a-11b] ---DA---WP 0011a-0011b
  [f011c-f011c]  PTE[11c]     ----A---WP 0011c
  [f011d-f011d]  PTE[11d]     ---DA---WP 0011d
  [f011e-f015b]  PTE[11e-15b] ----A---WP 0011e-0015b
  [f015c-f03bd]  PTE[15c-3bd] ---DA---WP 0015c-003bd
  [f03be-f03ff]  PTE[3be-3ff] --------WP 003be-003ff
[f0400-f7fff]  PDE[3c1-3df] ----A--UWP
  [f0400-f7fff]  PTE[000-3ff] ---DA---WP 00400-07fff
[f8000-fffff]  PDE[3e0-3ff] -------UWP
  [f8000-fffff]  PTE[000-3ff] --------WP 08000-0ffff
```


| Entry | Base Virtual Address | Points to (logically):                    |
| ----- | -------------------- | ----------------------------------------- |
| 1023  | 0xF8000000           | Page table for top 4MB of physical memory |
| ...   | ...                  | remapped physical memory                  |
| 960   | 0xF0000000           | the beginning of remapped physical memory |
| 959   | 0xEFC00000           | kernel stack                              |
| 958   | 0xEF800000           | unmapped                                  |
| 957   | 0xEF400000           | Cur. Page Table (User R-)                 |
| 956   | 0xEF000000           | RO PAGES                                  |
| ...   | ...                  | unmapped                                  |
| 2     | 0x00800000           | unmapped                                  |
| 1     | 0x00400000           | unmapped                                  |
| 0     | 0x00000000           | unmapped                                  |

> **Question**
>
> 3. We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

Cite *CHAPTER 6 PROTECTION* [*Intel 80386 Programmer's Reference Manual*](https://pdos.csail.mit.edu/6.828/2018/readings/i386.pdf) as an explanation. Generally, there two main courses in address translation, i.e. segment translation and page translation, during which we have some strategies  to protect the memory access. However, as this point, we have only set up page translation, thus we mainly use the `Read/Write` and `User/Supervisor` bits in both page directory entry and page table entry.

> **Question**
>
> 4. What is the maximum amount of physical memory that this operating system can support? Why?

The maximum amount of physical memory that this operating system can support is  $4GB$.  This operating system offer two-stage address translation: one page directory and $2^{10}$ page tables. As for one page directory,  the operating system allocates $4KB$(which is the size of a page) and `sizeof(pde_t)=4`, thus we have $4KB/8B=2^{10}$ page directory  entries. That is to say we have at most $2^{10}$ page tables.  Similarly, each page table have $2^{10}$ page table entries. There is $2^{12}$ Bytes in a page. Overall, we can manage $2^{10+10+12}B=2^{32}B=4GB$ physical memory.
> **Question**
>
> 5. How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

If we actually had the maximum amount of physical memory, the space overhead for managing memory could be broken down into three categories: one page directory($4KB$) , $2^{10}$ page tables($2^{10} \times 4KB=4MB$) and $2^{20}$ `PageInfo` structs($2^{20} \times 8B=8MB$). Thus, the overall overhead is $8MB+4MB+4KB=12MB+4KB$.

> **Question**
>
> 6. Revisit the page table setup in `kern/entry.S` and `kern/entrypgdir.c`. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

We transition to running above `KERNBASE` after following instruction in `kern/entry.S`:

```assembly
	# Now paging is enabled, but we're still running at a low EIP
	# (why is this okay?).  Jump up above KERNBASE before entering
	# C code.
	mov	$relocated, %eax
	jmp	*%eax
```

We are able to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE because we set up a hand-written, trivial and  temporary page table `entry_pgdir` when we firstly enable paging(in `kern/entry.S`):

```asm
# Load the physical address of entry_pgdir into cr3.  entry_pgdir
	# is defined in entrypgdir.c.
	movl	$(RELOC(entry_pgdir)), %eax
	movl	%eax, %cr3
	# Turn on paging.
	movl	%cr0, %eax
	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
	movl	%eax, %cr0	
```

 This trivial page directory could translate two parts of virtual address space, that is `[KERNBASE, KERNBASE+4MB)` and `[0, 4MB)`, into the same physical addresses `[0, 4MB)`.  This 4MB region will be sufficient until we set up our real page table in `mem_init` (in `kern/entrypgdir.c`):

```c
__attribute__((__aligned__(PGSIZE)))
pde_t entry_pgdir[NPDENTRIES] = {
	// Map VA's [0, 4MB) to PA's [0, 4MB)
	[0]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,
	// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
	[KERNBASE>>PDXSHIFT]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W
};
```

It's necessary because this the virtual address region `[0, 4MB)`is critical for a few instructions in `entry.S` and then we never use it again.

> *Challenge!* Extend the JOS kernel monitor with commands to:
>
> - Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter `'showmappings 0x3000 0x5000'` to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.
> - Explicitly set, clear, or change the permissions of any mapping in the current address space.
> - Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!
> - Do anything else that you think might be useful later for debugging the kernel. (There's a good chance it will be!)

in `kern/monitor.c`:

```c++
void printfperm(pte_t *pte){
	cprintf("%c%c%c", (*pte & PTE_P)?'P':'-', (*pte & PTE_W)?'W':'-', (*pte & PTE_U)?'U':'-');
}

int
mon_showmappings(int argc, char **argv, struct Trapframe *tf){
	if(argc != 3){
		cprintf("Format error. Usage: showmappings [hexadecimal begin_addr] [hexadecimal end_addr]\n");
		return 0;
	}
	uintptr_t begin_addr = strtol(argv[1], NULL, 16), end_addr = strtol(argv[2], NULL, 16);
	if(begin_addr>=end_addr){
		cprintf("begin address shoule less than end address.");
		return 0;
	}
	pde_t *pgdir = KADDR(rcr3());
	for(uintptr_t va = begin_addr; va < end_addr; va+=PGSIZE) {
		pte_t *pte = pgdir_walk(pgdir, (const void *)va, 0);
		if(pte && (*pte & PTE_P)){ // page mapping exists
			physaddr_t pa = PTE_ADDR(*pte);
			cprintf("va:%08p-%08p\tpa:%08p-%08p\t", va, va +PGSIZE - 1, pa, pa + PGSIZE - 1);
			printfperm(pte);
			cprintf("\n");
		}else
			cprintf("va:%08p-%08p page mapping does not exist.\n", va, va +PGSIZE - 1);
	}
	return 0;
}
```

Always remember that a page mapping exists if and only if `pte && (*pte & PTE_P)`.

in `kern/monitor.c`:

```c++
int
mon_setpageperm(int argc, char **argv, struct Trapframe *tf){
	if(argc != 4 || !(strcmp(argv[2], "clear")==0 || strcmp(argv[2], "set")==0)){
		cprintf("Format error. Usage: setpageperm [hexadecimal address] [clear|set] [W|U]\n");
		return 0;
	}
	uintptr_t va = strtol(argv[1], NULL, 16);
	pde_t *pgdir = KADDR(rcr3());
	pte_t *pte = pgdir_walk(pgdir, (const char*)va, 0);
	if(pte && (*pte & PTE_P)){
		uint16_t perm;
		switch (argv[3][0]) {
			case 'W': perm = PTE_W; break;
			case 'U': perm = PTE_U; break;
			default: perm = 0;
		}
		cprintf("change va:%08p-%08p page mapping permissions.\n", va, va+PGSIZE-1);
		cprintf("\tBefore: ");
		printfperm(pte);
		cprintf("\n");
		if(strcmp(argv[2], "clear")==0)
			*pte = *pte & ~perm;
		else if (strcmp(argv[2], "set")==0)
			*pte = *pte | perm;
		cprintf("\tAfter:  ");
		printfperm(pte);
		cprintf("\n");
	}else
		cprintf("va:%08p-%08p page mapping does not exist.\n", va, va + PGSIZE - 1);
	return 0;
}
```

At this point, it is not suitable to set  or clear page directory/table entry flag`PET_P`, as this flag determines whether whether this address is part of the overall page translation mechanism.

in `kern/monitor.c`:

```c++
int
mon_memdisp(int argc, char **argv, struct Trapframe *tf){
	if(argc!=4){
mon_memdisp_format_error:
		cprintf("Format error. Usage: memdump [P|V: physical address or virtual address] [hexadecimal begin_addr] [hexadecimal end_addr]\n");
		return 0;
	}
	uintptr_t begin_addr = strtol(argv[2], NULL, 16), end_addr = strtol(argv[3], NULL, 16);
	if(begin_addr>=end_addr){
		cprintf("begin address shoule be less than end address.\n");
		return 0;
	}
	pde_t *pgdir = KADDR(rcr3());
	if(strcmp(argv[1], "V") == 0){
		for(uintptr_t va = begin_addr; va < end_addr; va++){
			pte_t* pte = pgdir_walk(pgdir, (const void*)va, 0);
			if (pte && (*pte & PTE_P))
				cprintf("va: %08p\tcontent: %2x\n", va, *(unsigned char*)va);
			else
				cprintf("va: %08p\tMapping does not exist.\n", va);
		}
    }else if(strcmp(argv[1], "P") == 0){
		for(physaddr_t pa = begin_addr; pa < end_addr; pa++){
			void *va = KADDR(pa);
			pte_t* pte = pgdir_walk(pgdir, va, 0); // use page tablee to determine whether the physical address exists.
			if (!pte)
				cprintf("pa: %08p\tPhysical address does not exist.\n", pa);
			else
				cprintf("pa: %08p\tcontent: %2x\n", pa, *(unsigned char*)va);
		}
	}else
		goto mon_memdisp_format_error;
	return 0;
}
```

As for checking whether  the range extends across page boundaries, we use the mechanism of page translation, as it have to information about the total available physical memory.

I add some test cases in `kern/monitor.c`. 

```c++
	// Test showmappings
	runcmd("setpageperm 0xf0000000 set U", tf);
	runcmd("showmappings 0xEFFFC000 0xf0010000", tf);
	runcmd("memdisp V 0xf0000000 0xf0000010", tf);
	runcmd("memdisp P 0x00000000 0x00000010", tf);
	
```

And the result is following. We could see this pieces of code work correctly.

```
change va:0xf0000000-0xf0000fff page mapping permissions.
             Before: PW-
             After:  PWU
va:0xefffc000-0xefffcfff             pa:0x00114000-0x00114fff        PW-
va:0xefffd000-0xefffdfff             pa:0x00115000-0x00115fff        PW-
va:0xefffe000-0xefffefff             pa:0x00116000-0x00116fff        PW-
va:0xeffff000-0xefffffff             pa:0x00117000-0x00117fff        PW-
va:0xf0000000-0xf0000fff             pa:0x00000000-0x00000fff        PWU
va:0xf0001000-0xf0001fff             pa:0x00001000-0x00001fff        PW-
va:0xf0002000-0xf0002fff             pa:0x00002000-0x00002fff        PW-
va:0xf0003000-0xf0003fff             pa:0x00003000-0x00003fff        PW-
va:0xf0004000-0xf0004fff             pa:0x00004000-0x00004fff        PW-
va:0xf0005000-0xf0005fff             pa:0x00005000-0x00005fff        PW-
va:0xf0006000-0xf0006fff             pa:0x00006000-0x00006fff        PW-
va:0xf0007000-0xf0007fff             pa:0x00007000-0x00007fff        PW-
va:0xf0008000-0xf0008fff             pa:0x00008000-0x00008fff        PW-
va:0xf0009000-0xf0009fff             pa:0x00009000-0x00009fff        PW-
va:0xf000a000-0xf000afff             pa:0x0000a000-0x0000afff        PW-
va:0xf000b000-0xf000bfff             pa:0x0000b000-0x0000bfff        PW-
va:0xf000c000-0xf000cfff             pa:0x0000c000-0x0000cfff        PW-
va:0xf000d000-0xf000dfff             pa:0x0000d000-0x0000dfff        PW-
va:0xf000e000-0xf000efff             pa:0x0000e000-0x0000efff        PW-
va:0xf000f000-0xf000ffff             pa:0x0000f000-0x0000ffff        PW-
va: 0xf0000000       content: 53
va: 0xf0000001       content: ff
va: 0xf0000002       content:  0
va: 0xf0000003       content: f0
va: 0xf0000004       content: 53
va: 0xf0000005       content: ff
va: 0xf0000006       content:  0
va: 0xf0000007       content: f0
va: 0xf0000008       content: c3
va: 0xf0000009       content: e2
va: 0xf000000a       content:  0
va: 0xf000000b       content: f0
va: 0xf000000c       content: 53
va: 0xf000000d       content: ff
va: 0xf000000e       content:  0
va: 0xf000000f       content: f0
pa: 0x00000000       content: 53
pa: 0x00000001       content: ff
pa: 0x00000002       content:  0
pa: 0x00000003       content: f0
pa: 0x00000004       content: 53
pa: 0x00000005       content: ff
pa: 0x00000006       content:  0
pa: 0x00000007       content: f0
pa: 0x00000008       content: c3
pa: 0x00000009       content: e2
pa: 0x0000000a       content:  0
pa: 0x0000000b       content: f0
pa: 0x0000000c       content: 53
pa: 0x0000000d       content: ff
pa: 0x0000000e       content:  0
pa: 0x0000000f       content: f0
```

 The final result is:

```bash
running JOS: (2.4s)
  Physical page allocator: OK
  Page management: OK
  Kernel page directory: OK
  Page management 2: OK
Score: 70/70
```

**This completes the lab.** 